<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>openxava - basic-business-logic_es</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <div id="toc">
        <h1 class="nopad">Table of Contents</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-5-Logica-de-negocio-basica">Lección
            5: Lógica de negocio básica</a></div>
        <div style="margin-left: 2em;"><a href="#Propiedades-calculadas">Propiedades
            calculadas</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Propiedad-calculada-simple">Propiedad
            calculada simple</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Usar-DefaultValueCalculator">Usar
            @DefaultValueCalculator</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Propiedades-calculadas-dependientes-de-una-coleccion">Propiedades
            calculadas dependientes de una colección</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Valor-por-defecto-desde-un-archivo-de-propiedades">Valor
            por defecto desde un archivo de propiedades</a></div>
        <div style="margin-left: 2em;"><a href="#Metodos-de-retrollamadas-JPA">Métodos
            de retrollamadas JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario">Cálculo
            de valor por defecto multiusuario</a></div>
        <div style="margin-left: 3em;"><a href="#Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas">Sincronizar
            propiedades persistentes y calculadas</a></div>
        <div style="margin-left: 2em;"><a href="#Logica-desde-la-base-de-datos-Formula">Lógica
            desde la base de datos (@Formula)</a></div>
        <div style="margin-left: 2em;"><a href="#Pruebas-JUnit">Pruebas JUnit</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Modificar-la-prueba-existente">Modificar
            la prueba existente</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Verificar-valores-por-defecto-y-propiedades-calculadas">Verificar
            valores por defecto y propiedades calculadas</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Sincronizacion-entre-propiedad-persistente-y-calculada-Formula">Sincronización
            entre propiedad persistente y calculada / @Formula</a></div>
        <div style="margin-left: 2em;"><a href="#Resumen">Resumen</a></div>
      </div>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="modeling_es.html">2.
        Modelar con Java</a> | <a class="wiki_link" href="testing_es.html">3.
        Pruebas automáticas</a> | <a class="wiki_link" href="inheritance_es.html">4.
        Herencia</a> | <strong>5. Lógica de negocio básica</strong> | <a class="wiki_link"

        href="validation_es.html">6. Validación avanzada</a> | <a class="wiki_link"

        href="refining-standard-behavior_es.html">7. Refinar el comportamiento
        predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">8.
        Comportamiento y lógica de negocio</a> | <a class="wiki_link" href="references-collections_es.html">9.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a><br>
      <h1 id="toc0"><a name="Leccion-5-Logica-de-negocio-basica"></a>Lección 5:
        Lógica de negocio básica</h1>
      Has convertido tu modelo del dominio en una aplicación web plenamente
      funcional. Esta aplicación ya es bastante útil de por sí, aunque aún
      puedes hacerle muchas mejoras. Transformemos pues tu aplicación en algo
      más serio, y de paso, aprendamos algunas cosas interesantes sobre
      OpenXava.<br>
      Empezaremos por añadir algo de lógica de negocio a tus entidades para
      hacer de tu aplicación algo más que un simple gestor de base de datos.<br>
      <h2 id="toc1"><a name="Propiedades-calculadas"></a>Propiedades calculadas</h2>
      Quizás la lógica de negocio más simple que puedes añadir a tu aplicación
      es una propiedad calculada. Las propiedades que has usado hasta ahora son
      persistentes, es decir, cada propiedad se almacena en una columna de una
      tabla de la base de datos. Una propiedad calculada es una propiedad que no
      almacena su valor en la base de datos, sino que se calcula cada vez que se
      accede a la propiedad. Observa la diferencia entre una propiedad
      persistente y una calculada:<br>
      <pre><code class="java">// Propiedad persistente
private int cantidad; // Tiene un campo, por tanto es persistente
 
public int getCantidad() { // Un getter para devolver el valor del campo
    return cantidad;
}
 
public void setCantidad(int cantidad) { // Cambia el valor del campo
    this.cantidad = cantidad;
}
 
// Propiedad calculada
public int getImporte() { // No tiene campo, ni setter, solo un getter
    return cantidad * precio; // con un cálculo
}
</code></pre> Las propiedades calculadas son reconocidas automáticamente por
      OpenXava. Puedes usarlas en vistas, listas tabulares o cualquier otra
      parte de tu código.<br>
      Vamos a usar propiedades calculadas para añadir el elemento “económico” a
      nuestra aplicación <em>Facturacion</em>. Porque, tenemos líneas de
      detalle, productos, cantidades. Pero, ¿qué pasa con el dinero?<br>
      <h3 id="toc2"><a name="Propiedades-calculadas-Propiedad-calculada-simple"></a>Propiedad
        calculada simple</h3>
      El primer paso será añadir una propiedad de importe a <em>Detalle</em>.
      Lo que queremos es que cuando el usuario elija un producto y teclea la
      cantidad el importe de la línea sea recalculado y mostrado al usuario:<br>
      <img src="files/business-logic_es010.png" alt="business-logic_es010.png" title="business-logic_es010.png"><br>
      Añadir esta funcionalidad a tu actual código es prácticamente añadir una
      propiedad calculada a <em>Detalle</em>. Simplemente añade el código
      siguiente a la clase <em>Detalle</em>:<br>
      <pre><code class="java">@Stereotype("DINERO")
@Depends("producto.numero, cantidad") // Cuando usuario cambie producto o cantidad
public BigDecimal getImporte() { // esta propiedad se recalculará y se redibujará
    return new BigDecimal(cantidad).multiply(producto.getPrecio());
}
</code></pre> Es tan solo poner el cálculo en <em>getImporte()</em> y usar <em>@Depends</em>
      para indicar a OpenXava que la propiedad <em>importe</em> depende de <em>producto.numero</em>
      y <em>cantidad</em>, así cada vez que el usuario cambia alguno de estos
      valores la propiedad se recalculará.<br>
      Ahora has de añadir esta nueva propiedad a la lista de propiedades
      mostradas en la colección <em>detalles</em> de <em>DocumentoComercial</em>:<br>
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad, importe") // importe añadida
private Collection&lt;Detalle&gt; detalles;
</code></pre> Nada más. Tan solo necesitas añadir el getter y modificar la lista
      de propiedades. Ahora puedes probar los módulos <em>Factura</em> y <em>Pedido</em>
      para ver la propiedad <em>importe</em> en acción.<br>
      <table class="wiki_table">
        <tbody>
          <tr>
            <td><strong>Nota:</strong><br>
              <em>Verifica que los productos tengan precio registrado.</em><br>
            </td>
          </tr>
        </tbody>
      </table>
      <h3 id="toc3"><a name="Propiedades-calculadas-Usar-DefaultValueCalculator"></a>Usar
        <em>@DefaultValueCalculator</em></h3>
      La forma en que calculamos el importe de la línea de detalle no es la
      mejor. Tiene, al menos, dos inconvenientes. El primero es que el usuario
      puede querer tener la posibilidad de cambiar el precio unitario. Y
      segundo, si el precio de un producto cambia los importes de todas las
      facturas cambian también, y esto no es bueno.<br>
      Para evitar estos inconvenientes lo mejor es almacenar el precio de cada
      producto en cada línea de detalle. Añadamos pues una propiedad persistente
      <em>precioPorUnidad</em> a la clase <em>Detalle</em>, y calculemos su
      valor desde <em>precio</em> de <em>Producto</em> usando un <em>@DefaultValueCalculator</em>.
      De tal forma que consigamos el efecto que puedes ver en la siguiente
      figura:<br>
      <img src="files/business-logic_es020.png" alt="business-logic_es020.png" title="business-logic_es020.png"><br>
      El primer paso es obviamente añadir la propiedad <em>precioPorUnidad</em>.
      Añade el siguiente código a la clase <em>Detalle</em>:<br>
      <pre><code class="java">@DefaultValueCalculator(
    value=CalculadorPrecioPorUnidad.class, // Esta clase calcula el valor inicial
    properties=@PropertyValue(
        name="numeroProducto", // La propiedad numeroProducto del calculador...
        from="producto.numero") // ... se llena con el valor de producto.numero de la entidad
)
@Stereotype("DINERO")
private BigDecimal precioPorUnidad; // Una propiedad persistente convencional...
 
public BigDecimal getPrecioPorUnidad() { // ... con sus getter y setter
    return precioPorUnidad == null ? BigDecimal.ZERO : precioPorUnidad; // así nunca devuelve nulo
}
 
public void setPrecioPorUnidad(BigDecimal precioPorUnidad) {
    this.precioPorUnidad = precioPorUnidad;
}
</code></pre> <em>CalculadorPrecioPorUnidad</em> contiene la lógica para
      calcular el valor inicial. Simplemente lee el precio del producto. Observa
      el código de este calculador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.calculadores; // En el paquete calculadores
 
import org.openxava.calculators.*;
import com.tuempresa.facturacion.modelo.*;
 
import static org.openxava.jpa.XPersistence.*; //Para usar getManager()
 
public class CalculadorPrecioPorUnidad implements ICalculator {
 
    private int numeroProducto;
 
    @Override
    public Object calculate() throws Exception {
        Producto producto = getManager() // getManager() de XPersistence
            .find(Producto.class, numeroProducto); // Busca el producto
        return producto.getPrecio();    // Retorna su precio
    }
 
    public int getNumeroProducto() {
        return numeroProducto;
    }
 
    public void setNumeroProducto(int numeroProducto) {
        this.numeroProducto = numeroProducto;
    }
}
</code></pre> De esta forma cuando el usuario escoge un producto el campo de
      precio unitario se rellena con el precio del producto, pero, dado que es
      una propiedad persistente, el usuario puede cambiar este valor. Y si en el
      futuro el precio del producto cambiara este precio unitario de la línea de
      detalle no cambiaría.<br>
      Esto implica que has de adaptar la propiedad calculada <em>importe</em>:<br>
      <pre><code class="java">@Stereotype("DINERO")
@Depends("precioPorUnidad, cantidad") // precioPorUnidad en vez de producto.numero
public BigDecimal getImporte() {
    return new BigDecimal(cantidad).multiply(getPrecioPorUnidad()); // getPrecioPorUnidad() en vez de producto.getPrecio()
}
</code></pre> Ahora <em>getImporte()</em> usa <em>precioPorUnidad</em> como
      fuente en lugar de <em>producto.precio</em>.<br>
      Finalmente, debemos editar la entidad <em>DocumentoComercial</em> y
      modificar la lista de propiedades de la colección para mostrar la nueva
      propiedad:<br>
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad, precioPorUnidad, importe") // precioPorUnidad añadida
private Collection&lt;Detalle&gt; detalles;
</code></pre> Prueba los módulos <em>Pedido</em> y <em>Factura</em> y podrás
      observar el nuevo comportamiento al añadir líneas de detalle.<br>
      <h3 id="toc4"><a name="Propiedades-calculadas-Propiedades-calculadas-dependientes-de-una-coleccion"></a>Propiedades
        calculadas dependientes de una colección</h3>
      También queremos añadir importes a <em>Pedido</em> y <em>Factura</em>.
      Tener IVA, importe base e importe total es indispensable. Para hacerlo
      solo necesitas añadir unas pocas propiedades calculadas. La siguiente
      figura muestra la interfaz de usuario para estas propiedades:<br>
      <img src="files/business-logic_es030.png" alt="business-logic_es030.png" title="business-logic_es030.png"><br>
      Empecemos con <em>importeBase</em>. El siguiente código muestra su
      implementación:<br>
      <pre><code class="java">public BigDecimal getImporteBase() {
    BigDecimal resultado = new BigDecimal("0.00");
    for (Detalle detalle : getDetalles()) { // Iteramos por todas las líneas de detalle
        resultado = resultado.add(detalle.getImporte()); // Acumulamos el importe
    }
    return resultado;
}
</code></pre> La implementación es simple, se trata de sumar los importes de
      todas las líneas.<br>
      La siguiente propiedad a añadir es <em>porcentajeIVA</em> que se usará
      para calcular el <em>IVA</em>. El siguiente código muestra su
      implementación:<br>
      <pre><code class="java">@Digits(integer=2, fraction=0) // Para indicar su tamaño
@Required
private BigDecimal porcentajeIVA;
 
public BigDecimal getPorcentajeIVA() {
    return porcentajeIVA == null ? BigDecimal.ZERO : porcentajeIVA; // Así nunca es nulo
}
 
public void setPorcentajeIVA(BigDecimal porcentajeIVA) {
    this.porcentajeIVA = porcentajeIVA;
}
</code></pre> Puedes ver como <em>porcentajeIVA</em> es una propiedad
      persistente convencional. En este caso usamos <em>@Digits</em> (una
      anotación del entorno de validación Hibernate Validator) como una
      alternativa a <em>@Column</em> para especificar el tamaño.<br>
      Continuaremos añadiendo la propiedad <em>IVA</em>. La puedes ver en el
      siguiente código:<br>
      <pre><code class="java">public BigDecimal getIva() {
    return getImporteBase() // importeBase * porcentajeIVA / 100
        .multiply(getPorcentajeIVA())
        .divide(new BigDecimal(100));
}
</code></pre> Es un cálculo simple.<br>
      Solo nos queda <em>importeTotal</em> por añadir. Puedes ver su código:<br>
      <pre><code class="java">public BigDecimal getImporteTotal() {
    return getImporteBase().add(getIva()); //importeBase + iva
}
</code></pre> Una vez más un cálculo simple.<br>
      Ahora que ya has escrito las propiedades para los importes de <em>DocumentoComercial</em>,
      tienes que modificar la vista por defecto para mostrar <em>porcentajeIVA</em>
      y la lista de propiedades de la colección <em>detalles</em> para mostrar
      las <a class="wiki_link" href="view_es#Vista-Personalizaci%C3%B3n+de+colecci%C3%B3n-Propiedades+de+total+%28nuevo+en+v4.3%29">propiedades
        de total</a> de <em>DocumentoComercial</em>. Veamos una primera
      aproximación:<br>
      <pre><code class="java">@Entity
@View(members=
    "anyo, numero, fecha, porcentajeIVA;" + // Añadido porcentajeIVA
    "datos {" +
        "cliente;" +
        "detalles;" +
        "observaciones" +
    "}"
)
abstract public class DocumentoComercial extends Identificable {
 
    @ElementCollection
    @ListProperties(
        "producto.numero, producto.descripcion, cantidad, precioPorUnidad, " +
        "importe[factura.importeBase, factura.iva, factura.importeTotal]" // Entidad padre Factura =&gt; [factura.importeBase, ...]
    )
    private Collection&lt;Detalle&gt; detalles;
 
    // El resto del código fuente
    ...
}
</code></pre> Prueba el módulo <em>Factura</em> y observarás las nuevas
      propiedades calculadas, pero, si pruebas el módulo <em>Pedido</em> estas
      propiedades no se mostrarán y obtendrás una fea excepción en el log de
      Eclipse. Esto es así porque las propiedades de total para <em>Pedido</em>
      no han sido definidas, solo las hemos definido para <em>Factura</em>.
      Observa como definir <em>propiedades de total</em> para <em>Pedido</em>
      y <em>Factura</em> en el siguiente código:<br>
      <pre><code class="java">//  @ElementCollection
//  @ListProperties("producto.numero, producto.descripcion, cantidad, precioPorUnidad, " +
//     "importe[factura.importeBase, factura.iva, factura.importeTotal]" // Entidad padre Factura =&gt; [factura.importeBase, ...]
//  )
//  private Collection&lt;Detalle&gt; detalles; // La colección 'detalles' eliminada
//
//  public Collection&lt;Detalle&gt; getDetalles() { // Getter eliminado
//      return detalles;
//  }
//
//  public void setDetalles(Collection&lt;Detalle&gt; detalles) { // Setter eliminado
//      this.detalles = detalles;
//  }
 
abstract public Collection&lt;Detalle&gt; getDetalles(); // Añadido método abstracto
</code></pre> Primero eliminamos <em>detalles</em> de <em>DocumentoComercial</em>
      y declaramos un método abstracto que nos permitirá obtener los <em>detalles</em>
      de las subclases de <em>DocumentoComercial</em>.<br>
      Ahora veamos el código de <em>Factura</em> y <em>Pedido</em>:<br>
      <pre><code class="java">public class Factura extends DocumentoComercial {
 
    @ElementCollection
    @ListProperties("producto.numero, producto.descripcion, cantidad, precioPorUnidad, " +
        "importe[factura.importeBase, factura.iva, factura.importeTotal]"
    )
    private Collection&lt;Detalle&gt; detalles;
 
    public Collection&lt;Detalle&gt; getDetalles() { // Este método implementa el método abstracto de 'DocumentoComecial'
        return detalles;
    }
 
    public void setDetalles(Collection&lt;Detalle&gt; detalles) {
        this.detalles = detalles;
    }
 
    // El resto del código fuente
    ...
}
</code></pre>
      <pre><code class="java">public class Pedido extends DocumentoComercial {
 
    @ElementCollection
    @ListProperties("producto.numero, producto.descripcion, cantidad, precioPorUnidad, " +
        "importe[pedido.importeBase, pedido.iva, pedido.importeTotal]" // Entidad padre Pedido =&gt; [pedido.importeBase, ...]
    )
    private Collection&lt;Detalle&gt; detalles;
 
    public Collection&lt;Detalle&gt; getDetalles() { // Este método implementa el método abstracto de 'DocumentoComecial'
        return detalles;
    }
 
    public void setDetalles(Collection&lt;Detalle&gt; detalles) {
        this.detalles = detalles;
    }
 
    // El resto del código fuente
    ...
}
</code></pre> El código fuente añadido a <em>Factura</em> y <em>Pedido</em>
      generará dos tablas FACTURA_DETALLES y PEDIDO_DETALLES respectivamente.<br>
      <table class="wiki_table">
        <tbody>
          <tr>
            <td><strong>Nota:</strong><br>
              <em>Elimina la tabla DOCUMENTOCOMERCIAL_DETALLES, aprendiste a
                hacerlo en la lección anterior.</em><br>
            </td>
          </tr>
        </tbody>
      </table>
      Ahora puedes probar tu aplicación. Debería funcionar casi como en la
      figura del inicio de esta sección. “Casi” porque <em>porcentajeIVA</em>
      todavía no tiene un valor por defecto. Lo añadiremos en la siguiente
      sección.<br>
      <h3 id="toc5"><a name="Propiedades-calculadas-Valor-por-defecto-desde-un-archivo-de-propiedades"></a>Valor
        por defecto desde un archivo de propiedades</h3>
      Es conveniente para el usuario tener el campo <em>porcentajeIVA</em>
      lleno por defecto con un valor adecuado. Puedes usar un calculador (<em>@DefaultValueCalculator</em>)
      que devuelva un valor fijo, en este caso cambiar el valor por defecto
      implica cambiar el código fuente. O puedes leer el valor por defecto de
      una base de datos (usando JPA desde tu calculador), en este caso cambiar
      el valor por defecto implica actualizar la base de datos.<br>
      Otra opción es tener estos valores de configuración en un archivo de
      propiedades, un archivo plano con pares clave=valor. En este caso cambiar
      el valor por defecto de <em>porcentajeIVA</em> es tan simple como editar
      un archivo plano con un editor de texto.<br>
      Implementemos la opción del archivo de propiedades. Crea un archivo
      llamado <em>facturacion.properties</em> en la carpeta <em>Facturacion/properties</em>
      con el siguiente contenido:<br>
      <pre><code class="properties">porcentajeIVADefecto=18
</code></pre> Aunque puedes usar la clase <em>java.util.Properties</em> de Java
      para leer este archivo preferimos usar una clase propia para leer estas
      propiedades. Vamos a llamar a esta clase <em>PreferenciasFacturacion</em>
      y la pondremos en un nuevo paquete llamado <em>com.tuempresa.facturacion.util</em>.
      Veamos el código:<br>
      <pre><code class="java">package com.tuempresa.facturacion.util; // En el paquete 'util'
 
import java.io.*;
import java.math.*;
import java.util.*;
import org.apache.commons.logging.*;
import org.openxava.util.*;
 
public class PreferenciasFacturacion {
 
    private final static String ARCHIVO_PROPIEDADES="facturacion.properties";
    private static Log log = LogFactory.getLog(PreferenciasFacturacion.class);
 
    private static Properties propiedades; // Almacenamos las propiedades aquí
 
    private static Properties getPropiedades() {
        if (propiedades == null) { // Usamos inicialización vaga
            PropertiesReader reader = // PropertiesReader es una clase de OpenXava
                new PropertiesReader(
                    PreferenciasFacturacion.class, ARCHIVO_PROPIEDADES);
            try {
                propiedades = reader.get();
            }
            catch (IOException ex) {
                log.error(
                    XavaResources.getString( // Para leer un mensaje i18n
                        "properties_file_error",
                        ARCHIVO_PROPIEDADES),
                    ex);
                  propiedades = new Properties();
             }
        }
        return propiedades;
    }
 
    public static BigDecimal getPorcentajeIVADefecto() { // El único método público
        return new BigDecimal(getPropiedades().getProperty("porcentajeIVADefecto"));
    }
}
</code></pre> Como puedes ver <em>PreferenciasFacturacion</em> es una clase con
      un método estático, <em>getPorcentajeIVADefecto()</em>. La ventaja de
      usar esta clase en lugar de leer directamente del archivo de propiedades
      es que si cambias la forma en que se obtienen las preferencias, por
      ejemplo leyendo de una base de datos o de un directorio LDAP, solo has de
      cambiar esta clase en toda tu aplicación.<br>
      Puedes usar esta clase desde el calculador por defecto para la propiedad <em>porcentajeIVA</em>.
      Aquí tienes el código del calculador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.calculadores; // En el paquete 'calculadores'
 
import org.openxava.calculators.*; // Para usar 'ICalculator'
import com.tuempresa.facturacion.util.*; // Para usar 'PreferenciasFacturacion'
 
public class CalculadorPorcentajeIVA implements ICalculator {
 
    @Override
    public Object calculate() throws Exception {
        return PreferenciasFacturacion.getPorcentajeIVADefecto();
    }
}
</code></pre> Como ves, simplemente devuelve <em>porcentajeIVADefecto</em> de <em>PreferenciasFacturacion</em>.
      Ahora, ya puedes usar este calculador en la definición de la propiedad <em>porcentajeIVA</em>
      en <em>DocumentoComercial</em>. Mira el código:<br>
      <pre><code class="java">@DefaultValueCalculator(CalculadorPorcentajeIVA.class)
private BigDecimal porcentajeIVA;
</code></pre> Con este código cuando el usuario pulsa para crear una nueva
      factura, el campo <em>porcentajeIVA</em> se rellenará con 18, o cualquier
      otro valor que hayas puesto en <em>facturacion.properties</em>.<br>
      <h2 id="toc6"><a name="Metodos-de-retrollamadas-JPA"></a>Métodos de
        retrollamadas JPA</h2>
      Otra forma práctica de añadir lógica de negocio a tu modelo es mediante
      los métodos de retrollamada JPA. Un método de retrollamada se llama en un
      momento específico del ciclo de vida de la entidad como objeto
      persistente. Es decir, puedes especificar cierta lógica a ejecutar al
      grabar, leer, borrar o modificar una entidad.<br>
      En esta sección veremos algunas aplicaciones prácticas de los métodos de
      retrollamada JPA.<br>
      <h3 id="toc7"><a name="Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario"></a>Cálculo
        de valor por defecto multiusuario</h3>
      Hasta ahora estamos calculando el número para <em>Factura</em> y <em>Pedido</em>
      usando <em>@DefaultValueCalculator</em>. Éste calcula el valor por
      defecto en el momento que el usuario pulsa para crear una nueva <em>Factura</em>
      o <em>Pedido</em>. Por tanto, si varios usuarios pulsan en el botón
      “nuevo” al mismo tiempo todos ellos obtendrán el mismo número. Esto no es
      apto para aplicaciones multiusuario. La forma correcta de generar un
      número único es generándolo justo en el momento de grabar.<br>
      Vamos a implementar la generación del número usando métodos de
      retrollamada JPA. JPA permite marcar cualquier método de tu clase para ser
      ejecutado en cualquier momento de su ciclo de vida. Indicaremos que justo
      antes de grabar un <em>DocumentoComercial</em> calcule su número. De paso
      mejoraremos el cálculo para tener una numeración diferente para <em>Pedido</em>
      y <em>Factura</em>.<br>
      Edita la entidad <em>DocumentoComercial</em> y añade el método <em>calcularNumero()</em>.
      Veamos el código:<br>
      <pre><code class="java">@PrePersist // Ejecutado justo antes de grabar el objeto por primera vez
public void calcularNumero() {
    Query query = XPersistence.getManager().createQuery(
        "select max(f.numero) from " +
        getClass().getSimpleName() + // De esta forma es válido para Factura y Pedido
        " f where f.anyo = :anyo");
    query.setParameter("anyo", anyo);
    Integer ultimoNumero = (Integer) query.getSingleResult();
    this.numero = ultimoNumero == null ? 1 : ultimoNumero + 1;
}
</code></pre> El código anterior es el mismo que el de <em>CalculadorSiguienteNumeroParaAnyo</em>
      pero usando <em>getClass().getSimpleName()</em> en lugar de <em>DocumentoComercial</em>.
      El método <em>getSimpleName()</em> devuelve el nombre de la clase sin
      paquete, es decir, precisamente el nombre de la entidad. Será "Pedido"
      para <em>Pedido</em> y "Factura"" para <em>Factura</em>. Así podremos
      obtener una numeración diferente para <em>Factura</em> y <em>Pedido</em>.<br>
      La especificación JPA establece que no puedes usar el API JPA dentro de un
      método de retrollamada. Por tanto, el método de arriba no es legal desde
      un punto de vista estricto. Pero, Hibernate (la implementación de JPA que
      OpenXava usa por defecto) te permite usarla en <em>@PrePersist</em>. Y
      dado que usar JPA es la forma más fácil de hacer este cálculo, nosotros lo
      usamos.<br>
      Ahora borra la clase <em>CalculadorSiguienteNumeroParaAnyo</em> de tu
      proyecto, y modifica la propiedad <em>numero</em> de <em>DocumentoComercial</em>
      para que no la use. Mira el siguiente código:<br>
      <pre><code class="java">@Column(length = 6)
//  @DefaultValueCalculator(value=CalculadorSiguienteNumeroParaAnyo.class, // Quita esto
//      properties=@PropertyValue(name="anyo")
//  )
@ReadOnly // El usuario no puede modificar el valor
private int numero;
</code></pre> Nota que, además de quitar <em>@DefaultValueCalculator</em>,
      hemos añadido la anotación <em>@ReadOnly</em>. Esto significa que el
      usuario no puede introducir ni modificar este número. Esta es la forma
      correcta de hacerlo ahora dado que el número es generado al grabar el
      objeto, por lo que el valor que tecleara el usuario sería sobrescrito
      siempre.<br>
      Prueba ahora el módulo de <em>Factura</em> o <em>Pedido</em>, verás como
      el número está vacío y no es editable, y cuando grabes el documento, el
      número se calcula y se actualiza en la interfaz de usuario.<br>
      <h3 id="toc8"><a name="Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas"></a>Sincronizar
        propiedades persistentes y calculadas</h3>
      La forma en que calculamos el IVA, el importe base y el importe total es
      natural y práctica. Usamos propiedades calculadas que calculan, usando
      Java puro, los valores cada vez que son llamadas.<br>
      Pero, las propiedades calculadas tienen algunos inconvenientes. Por
      ejemplo, si quieres hacer un proceso masivo o un informe de todas las
      facturas cuyo importe total esté entre ciertos rangos. En estos casos, si
      tienes una base de datos demasiado grande el proceso puede ser lentísimo,
      porque has de instanciar todas las facturas para calcular su importe
      total. Una solución para este problema es tener una propiedad persistente,
      por tanto una columna en la base de datos para el importe de la factura o
      pedido; así el rendimiento es bastante mayor.<br>
      En nuestro caso mantendremos nuestra actuales propiedades calculadas, pero
      vamos a añadir una nueva, llamada <em>importe</em>, que contendrá el
      mismo valor que <em>importeTotal</em>, pero <em>importe</em> será
      persistente con su correspondiente columna en la base de datos. Lo
      complicado aquí es mantener sincronizado el valor de la propiedad <em>importe</em>.
      Vamos a usar métodos de retrollamada JPA (y un truco más) en <em>DocumentoComercial</em>
      para conseguirlo.<br>
      El primer paso es añadir la propiedad <em>importe</em> a <em>DocumentoComercial</em>.
      Nada más fácil, puedes verlo en el siguiente código:<br>
      <pre><code class="java">@Stereotype("DINERO")
private BigDecimal importe;
 
public BigDecimal getImporte() {
    return importe;
}
 
public void setImporte(BigDecimal importe) {
    this.importe = importe;
}
</code></pre> Cuando el usuario añade, modifica o elimina un detalle en la
      interface de usuario, el iva, importe base e importe total son
      recalculados con datos frescos instantáneamente, no obstante, para
      persistir estos cambios el usuario debe Guardar el DocumentoComercial.
      Para sincronizar <em>importe</em> con <em>importeTotal</em> la primera
      vez que registramos un documento comercial, nosotros ya sabemos que
      debemos usar <em>@PrePersist</em>, pero, resulta que JPA no permite
      marcar más de un método con la misma anotación, por lo tanto, vamos a
      reordenar nuestro código. Veamos:<br>
      <pre><code class="java">// @PrePersist // Elimina esta anotación
public void calcularNumero() {
    Query query = XPersistence.getManager().createQuery(
        "select max(f.numero) from " +
        getClass().getSimpleName() + // De esta forma es válido para Factura y Pedido
        " f where f.anyo = :anyo");
    query.setParameter("anyo", anyo);
    Integer ultimoNumero = (Integer) query.getSingleResult();
    this.numero = ultimoNumero == null ? 1 : ultimoNumero + 1;
}
 
@PrePersist // Ejecutado justo antes de grabar el objeto por primera vez
private void preGrabar() throws Exception {
    calcularNumero();
    recalcularImporte();
}
 
public void recalcularImporte() {
    setImporte(getImporteTotal());
}
</code></pre> Básicamente, llamamos a <em>recalcularImporte()</em> cada vez que
      una entidad <em>DocumentoComercial</em> es registrada por primera vez en
      la base de datos. Pero, <em>recalcularImporte()</em> también debe ser
      ejecutado en la actualización de <em>detalles</em>. Una primera
      aproximación puede ser marcar <em>recalcularImporte</em> con <em>@PreUpdate</em>,
      pero este sería ejecutado solo cuando cambian las propiedades de <em>DocumentoComercial</em>,
      nunca cuando cambian <em>detalles</em>. Nosotros superaremos esto,
      ejecutando <em>recalcularImporte()</em> siempre que el usuario grabe un <em>DocumentoComercial</em>.
      Veamos el siguiente código:<br>
      <pre><code class="java">@Version
private Integer version; // Añadida propiedad 'version', sin getter, ni setter
 
@PreUpdate // Añadido '@PreUPdate'
public void recalcularImporte() { // Ejecutado justo antes de actualizar el objeto
    setImporte(getImporteTotal());
}
</code></pre> La <a class="wiki_link" href="model_es#Modelo-Propiedades-Concurrencia+y+propiedad+versi%C3%B3n">propiedad
        version</a> asegura que la retrollamada <em>@PreUpdate</em> sea
      ejecutada siempre que el usuario Salve un <em>DocumentoComercial</em>,
      porque esta propiedad siempre será actualizada al guardar.<br>
      Puedes probar los módulos Factura y Pedido con este código y verás que
      cuando una línea de detalle se añade, remueve o modifica, la columna <em>importe</em>
      en la base de datos es correctamente actualizada después de grabar, lista
      para ser usada en un proceso masivo.<br>
      <table class="wiki_table">
        <tbody>
          <tr>
            <td><strong>Nota:</strong><br>
              <em>Elimina la tabla DOCUMENTOCOMERCIAL para que se vuelva a
                generar incluyendo la columna "version"</em>.<br>
            </td>
          </tr>
        </tbody>
      </table>
      <h2 id="toc9"><a name="Logica-desde-la-base-de-datos-Formula"></a>Lógica
        desde la base de datos (<em>@Formula</em>)</h2>
      Idealmente escribirás toda tu lógica de negocio en Java, dentro de tus
      entidades. Sin embargo, hay ocasiones que esto no es lo más conveniente.
      Imagina que tienes una propiedad calculada en <em>DocumentoComercial</em>,
      digamos <em>beneficioEstimado</em>, como la siguiente:<br>
      <pre><code class="java">@Stereotype("DINERO")
public BigDecimal getBeneficioEstimado() {
    return getImporte().multiply(new BigDecimal("0.10"));
}
</code></pre> Si necesitas realizar un proceso con todas las facturas con un <em>beneficioEstimado</em>
      mayor de 1000, has de escribir algo parecido al siguiente código:<br>
      <pre><code class="java">Query query = getManager().createQuery("from Factura"); // Sin condición en la consulta
for (Object o : query.getResultList()) { // Itera por todos los objetos
    Factura f = (Factura) o;
    if (f.getBeneficioestimado() // Pregunta a cada objeto
       .compareTo(new BigDecimal("1000")) &gt; 0) {
        f.doSomething();
    }
}
</code></pre> No puedes usar una condición en la consulta para discriminar por <em>beneficioEstimado</em>,
      porque <em>beneficioEstimado</em> no está en la base de datos, solo está
      en el objeto Java, por tanto tienes que instanciar cada objeto para
      preguntar por su <em>beneficioEstimado</em> A veces esto es una buena
      opción, pero si tienes una cantidad inmensa de facturas, y solo unas
      cuantas tienen el <em>beneficioEstimado</em> mayor de 1000, entonces el
      proceso será muy ineficiente. ¿Qué alternativa tenemos?<br>
      Nuestra alternativa es usar la anotación <em>@Formula</em>. <em>@Formula</em>
      es una extensión de Hibernate al JPA estándar, que te permite mapear tu
      propiedad contra un estamento SQL. Puedes definir <em>beneficioEstimado</em>
      con <em>@Formula</em> como muestra el siguiente código:<br>
      <pre><code class="java">@org.hibernate.annotations.Formula("IMPORTE * 0.10") // El cálculo usando SQL
@Stereotype("DINERO")
private BigDecimal beneficioEstimado; // Un campo, como con las propiedades persistentes
 
public BigDecimal getBeneficioEstimado() { // Sólo el getter es necesario
    return beneficioEstimado;
}
</code></pre> Esto indica que cuando un <em>DocumentoComercial</em> se lea de
      la base de datos, el campo <em>beneficioEstimado</em> se rellenará con el
      cálculo de <em>@Formula</em>, un cálculo que por cierto hace la base de
      datos. Lo más útil de las propiedades <em>@Formula</em> es que puedes
      usarlas en las condiciones, por tanto puedes reescribir el anterior
      proceso como muestra el siguiente código:<br>
      <pre><code class="java">Query query = getManager().createQuery(
    "from Factura f where f.beneficioEstimado &gt; :beneficioEstimado"); // Podemos usar una condición
query.setParameter("beneficioEstimado", new BigDecimal(1000));
for (Object o: query.getResultList()) { // Iteramos solo por los objetos seleccionados
    Factura f = (Factura) o;
    f.doSomething();
}
</code></pre> De esta forma pones el peso del cálculo de <em>beneficioEstimado</em>
      y la selección de los registros en el servidor de base de datos, y no el
      servidor Java.<br>
      Este hecho también tiene efecto en modo lista, porque el usuario no puede
      filtrar ni ordenar por propiedades calculadas, pero sí por propiedades con
      <em>@Formula</em>:<br>
      <img src="files/business-logic_es040.png" alt="business-logic_es040.png" title="business-logic_es040.png"><br>
      <em>@Formula</em> es una buena opción para mejorar el rendimiento en
      algunos casos. De todas formas, generalmente es mejor usar propiedades
      calculadas y escribir así tu lógica en Java. La ventaja de las propiedades
      calculadas sobre <em>@Formula</em> es que tu código no es dependiente de
      la base de datos. Además, con las propiedades calculadas puedes reejecutar
      el cálculo sin tener que leer el objeto de la base de datos, por tanto
      puedes usar <em>@Depends</em>.<br>
      <h2 id="toc10"><a name="Pruebas-JUnit"></a>Pruebas JUnit</h2>
      Antes de ir a la siguiente lección, vamos a escribir el código JUnit para
      ésta. Recuerda, el código no está terminado si no tiene pruebas JUnit.
      Puedes escribir las pruebas antes, durante o después del código principal.
      Pero siempre has de escribirlas.<br>
      El código de prueba mostrado aquí no es solo para darte un buen ejemplo,
      sino también para enseñarte maneras de probar diferentes casos en tu
      aplicación OpenXava.<br>
      <h3 id="toc11"><a name="Pruebas-JUnit-Modificar-la-prueba-existente"></a>Modificar
        la prueba existente</h3>
      Crear una nueva prueba para cada nuevo caso parece una buena idea desde un
      punto de vista estructural, pero en la mayoría de los casos no es
      práctico, porque de esa forma tu código de prueba crecerá muy rápido, y
      con el tiempo, ejecutar todas las pruebas supondrá muchísimo tiempo.<br>
      El enfoque más pragmático es modificar el código de prueba existente para
      cubrir todos los nuevos casos que hemos desarrollado. Hagámoslo de esta
      forma.<br>
      En nuestro caso, todo el código de esta lección aplica a <em>DocumentoComercial</em>,
      por tanto vamos a modificar el método <em>testCrear()</em> de <em>PruebaDocumentoComercial</em>
      para ajustarlo a la nueva funcionalidad. Dejamos el método <em>testCrear()</em>
      tal como muestra el siguiente código:<br>
      <pre><code class="java">public void testCrear() throws Exception {
    login("admin", "admin");
    calcularNumero(); // Añadido para calcular primero el siguiente número de documento
    verificarValoresDefecto();
    escogerCliente();
    anyadirDetalles();
    ponerOtrasPropiedades();
    grabar();
    verificarImporteYBeneficioEstimado(); // Prueba el método de retrollamada y @Formula
    verificarCreado();
    borrar();
}
</code></pre> Como ves, añadimos una nueva línea, después de <em>login(...)</em>,
      para calcular el siguiente número de documento, y una llamada al nuevo
      método <em>verificarImporteYBeneficioEstimado()</em>.<br>
      Ahora nos conviene más calcular el siguiente número de documento al
      principio para usarlo en el resto de la prueba. Para hacer esto, cambia el
      viejo método <em>getNumero()</em> por los dos métodos mostrados en el
      siguiente código:<br>
      <pre><code class="java">private void calcularNumero() {
    Query query = getManager().createQuery(
        "select max(f.numero) from " +
        modelo + // Cambiamos DocumentoComercial por una variable
        " f where f.anyo = :anyo");
    query.setParameter("anyo", Dates.getYear(new Date()));
    Integer ultimoNumero = (Integer) query.getSingleResult();
    if (ultimoNumero == null) ultimoNumero = 0;
    numero = Integer.toString(ultimoNumero + 1);
}
 
private String getNumero() {
    return numero;
}
</code></pre> Anteriormente, teníamos solo <em>getNumero()</em> que calculaba y
      devolvía el número, ahora tenemos un método para calcular (<em>calcularNumero()</em>),
      y otro para devolver el resultado (<em>getNumero()</em>). Puedes notar que
      la lógica del cálculo tiene un pequeño cambio, en vez de usar
      “DocumentoComercial” como fuente de la consulta usamos "modelo", una
      variable. Esto es así porque ahora la numeración para facturas y pedidos
      está separada. Llenamos esta variable, un campo de la clase de prueba, en
      el constructor, tal como muestra el siguiente código:<br>
      <pre><code class="java">private String modelo; // Nombre del modelo para la condición. Puede ser 'Factura' o 'Pedido'
 
public PruebaDocumentoComercial(String nombrePrueba, String nombreModulo) {
    super(nombrePrueba, "Facturacion", nombreModulo);
    this.modelo = nombreModulo; // El nombre del módulo coincide con el del modelo
}
</code></pre> En este caso el nombre de módulo, "Factura" o "Pedido", coincide
      con el nombre de modelo, <em>Factura</em> o <em>Pedido</em>, así que la
      forma más fácil de obtener el nombre de modelo es desde el nombre de
      módulo.<br>
      Veamos el código que prueba la nueva funcionalidad.<br>
      <h3 id="toc12"><a name="Pruebas-JUnit-Verificar-valores-por-defecto-y-propiedades-calculadas"></a>Verificar
        valores por defecto y propiedades calculadas</h3>
      En esta lección hemos hecho algunas modificaciones en los valores por
      defecto. Primero, el valor por defecto para <em>numero</em> ya no se
      calcula mediante un <em>@DefaultValueCalculator</em> en su lugar usamos
      un método de retrollamada JPA. Segundo, tenemos una nueva propiedad, <em>porcentajeIVA</em>,
      cuyo valor inicial se calcula leyendo de un archivo de propiedades. Para
      probar estos casos hemos de modificar el método <em>verificarValoresDefecto()</em>
      como ves en el siguiente código:<br>
      <pre><code class="java">private void verificarValoresDefecto() throws Exception {
    execute("CRUD.new");
    assertValue("anyo", getAnyoActual());
    // assertValue("numero", getNumero()); // Ahora el número no tiene valor inicial...
    assertValue("numero", ""); // ... al crear un documento nuevo
    assertValue("fecha", getFechaActual());
    assertValue("porcentajeIVA", "18"); // Valor de archivo de propiedades
}
</code></pre> Comprobamos el cálculo del valor por defecto de <em>procentajeIVA</em>
      y verificamos que <em>numero</em> no tiene valor inicial, porque ahora <em>numero</em>
      no se calcula hasta el momento de grabar el documento (sección <a class="wiki_link"

        href="basic-business-logic_es.html#Lecci%C3%B3n+5:+L%C3%B3gica+de+negocio+b%C3%A1sica-M%C3%A9todos+de+retrollamadas+JPA-C%C3%A1lculo+de+valor+por+defecto+multiusuario">Cálculo
        de valor por defecto multiusuario</a>). Cuando el documento (factura o
      pedido) se grabe verificaremos que <em>numero</em> se calcula. Cuando la
      línea se añade podemos verificar el cálculo de <em>importe</em> de <em>detalle</em>
      (la propiedad calculada simple, sección <a class="wiki_link" href="basic-business-logic_es.html#Lecci%C3%B3n+5:+L%C3%B3gica+de+negocio+b%C3%A1sica-Propiedades+calculadas-Propiedad+calculada+simple">Propiedad
        calculada simple</a>), el valor por defecto para <em>precioPorUnidad</em>
      (<em>@DefaultValueCalculator</em>, sección <a class="wiki_link" href="basic-business-logic_es.html#Lecci%C3%B3n+5:+L%C3%B3gica+de+negocio+b%C3%A1sica-Propiedades+calculadas-Usar+@DefaultValueCalculator">Usar
        @DefaultValueCalculator</a>) y las propiedades de importes del documento
      (propiedades calculadas que dependen de una colección, sección <a class="wiki_link"

        href="basic-business-logic_es.html#Lecci%C3%B3n+5:+L%C3%B3gica+de+negocio+b%C3%A1sica-Propiedades+calculadas-Propiedades+calculadas+dependientes+de+una+colecci%C3%B3n">Propiedades
        calculadas dependientes de una colección</a>). Probamos todo esto
      haciendo unas ligeras modificaciones en el ya existente método <em>anyadirDetalles()</em>:<br>
      <pre><code class="java">private void anyadirDetalles() throws Exception {
    assertCollectionRowCount("detalles", 0);
 
    // Añadir una línea de detalle
    setValueInCollection("detalles", 0, "producto.numero", "1");
    assertValueInCollection("detalles", 0,
        "producto.descripcion", "Peopleware: Productive Projects and Teams");
    assertValueInCollection("detalles", 0,
        "precioPorUnidad", "31,00"); // @DefaultValueCalculator, section 'Usar @DefaultValueCalculator'
    setValueInCollection("detalles", 0, "cantidad", "2");
    assertValueInCollection("detalles", 0,
        "importe", "62,00"); // Propiedada calculada, sección 'Propiedad calculada simple'
 
    // Verificando propiedades calculadas del documento
    assertTotalInCollection("detalles", 0, "importe", "62,00"); // Propiedades calculadas
    assertTotalInCollection("detalles", 1, "importe", "11,16");  // dependientes de una coleccion,
    assertTotalInCollection("detalles", 2,
        "importe", "73,16"); // sección 'Propiedades calculadas dependientes de una colección'
 
    // Añadir otro detalle
    setValueInCollection("detalles", 1, "producto.numero", "2");
    assertValueInCollection("detalles", 1, "producto.descripcion", "Arco iris de lágrimas");
    assertValueInCollection("detalles", 1,
        "precioPorUnidad", "15,00"); // @DefaultValueCalculator, sección 'Usar @DefaultValueCalculator'
    setValueInCollection("detalles", 1, "precioPorUnidad", "10,00"); // Modificando el valor pode defecto
    setValueInCollection("detalles", 1, "cantidad", "1");
    assertValueInCollection("detalles", 1, "importe", "10,00");
 
    assertCollectionRowCount("detalles", 2);
 
    // Verificando propiedades calculadas del documento
    assertTotalInCollection("detalles", 0, "importe", "72,00");
    assertTotalInCollection("detalles", 1, "importe", "12,96");
    assertTotalInCollection("detalles", 2, "importe", "84,96");
}
</code></pre> Como ves, con estas modificaciones sencillas probamos la mayoría
      de nuestro nuevo código. Nos quedan sólo las propiedades <em>importe</em>
      y <em>beneficioEstimado</em>. Las cuales probaremos en la siguiente
      sección.<br>
      <h3 id="toc13"><a name="Pruebas-JUnit-Sincronizacion-entre-propiedad-persistente-y-calculada-Formula"></a>Sincronización
        entre propiedad persistente y calculada / <em>@Formula</em></h3>
      En la sección <a class="wiki_link" href="basic-business-logic_es.html#Lecci%C3%B3n+5:+L%C3%B3gica+de+negocio+b%C3%A1sica-M%C3%A9todos+de+retrollamadas+JPA-Sincronizar+propiedades+persistentes+y+calculadas">Sincronizar
        propiedades persistentes y calculadas</a> usamos métodos de retrollamada
      de JPA en <em>DocumentoComercial</em> para tener una propiedad
      persistente, <em>importe</em>, sincronizada con una calculada, <em>importeTotal</em>.
      La propiedad <em>importe</em> solo se muestra en modo lista.<br>
      En la sección <a class="wiki_link" href="basic-business-logic_es.html#Lecci%C3%B3n+5:+L%C3%B3gica+de+negocio+b%C3%A1sica-L%C3%B3gica+desde+la+base+de+datos+%28@Formula%29">Lógica
        desde la base de datos</a> hemos creado una propiedad que usa <em>@Formula</em>,
      <em>beneficioEstimado</em>. Esta propiedad se muestra solo en modo lista.<br>
      Obviamente, la forma más simple de probarlo es yendo a modo lista y
      verificando que los valores para estas dos propiedades son los esperados.
      En <em>testCrear()</em> llamamos a <em>verificarImporteYBeneficioEstimado()</em>.
      Veamos su código:<br>
      <pre><code class="java">private void verificarImporteYBeneficioEstimado() throws Exception {
    execute("Mode.list"); // Cambiar a modo lista
    setConditionValues(new String [] { // Filtra para ver en la lista solamente
        getAnyoActual(), getNumero() // el documento que acabamos de crear
    });
    execute("List.filter"); // Hace filtro
    assertValueInList(0, 0, getAnyoActual()); // Verifica que
    assertValueInList(0, 1, getNumero()); // el filtro ha funcionado
    assertValueInList(0, "importe", "84,96"); // Confirma el importe
    assertValueInList(0, "beneficioEstimado", "8,50"); // Confirma el beneficio estimado
    execute("List.viewDetail", "row=0"); // Va a modo detalle
}
</code></pre> Dado que ahora vamos a modo lista y después volvemos a detalles,
      hemos de hacer una pequeña modificación en el método <em>verificarCreado()</em>,
      que es ejecutado justo después de <em>verificarImporteYBeneficioEstimado()</em>.
      Veamos la modificación:<br>
<pre><code class="java">private void verificarCreado() throws Exception {
    // setValue("anyo", getAnyoActual()); // Borramos estas líneas
    // setValue("numero", getNumero());  // para buscar el documento
    // execute("CRUD.refresh"); // porque ya lo hemos buscado desde el modo lista
    // El resto de la prueba ...
    ...
</code></pre>
      Quitamos estas líneas porque ahora no es necesario buscar el documento
      recién creado. Ahora en el método <em>verificarImporteYBeneficioEstimado()</em>
      vamos a modo lista y escogemos el documento, por tanto ya estamos editando
      el documento.<br>
      ¡Enhorabuena! Ahora tus pruebas ya están sincronizadas con tu código. Es
      un buen momento para ejecutar todas las pruebas de tu aplicación.<br>
      <h2 id="toc14"><a name="Resumen"></a>Resumen</h2>
      En esta lección has aprendido algunas formas comunes de añadir lógica de
      negocio a tus entidades. No hay duda sobre la utilidad de las propiedades
      calculadas, los métodos de retrollamada o <em>@Formula</em>. Sin embargo,
      todavía tenemos muchas otras formas de añadir lógica a tu aplicación
      OpenXava, que vamos a aprender a usar.<br>
      En futuros lecciones verás como añadir validación, modificar el
      funcionamiento estándar del módulo y añadir tu propia lógica de negocio,
      entre otras formas de añadir lógica personalizada a tu aplicación.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-5-basic-business-logic_es.zip/download"

          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"

          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="validation_es.html">Ve a la lección 6</a></strong>
    </div>
  </body>
</html>
